-- Requires Rank N quantification (work in progress)

-- FreeM monad data type (in multiplicative style)
data FreeM (f : Type → Type) a where
  Pure   : a → FreeM f a;
  Impure : f (FreeM f a) → FreeM f a

return : forall {a : Type, f : Type -> Type} . a -> FreeM f a
return x = Pure x

bind : ∀ {a : Type, b : Type, f : Type → Type} .
       ((FreeM f a → FreeM f b) → f (FreeM f a) → f (FreeM f b)) [Any] → FreeM f a → (a → FreeM f b) → FreeM f b
bind [fmap] y k =
  case y of
    (Pure x)   -> k x;
    (Impure d) -> Impure (fmap (λ(x : FreeM f a) → bind [fmap] x k) d)

-- -------------------------------------

data State = Get | Put

data StateOps (s : Type) (r : Type) : State -> Type where
 GetOp : () -> (s -> r)  -> StateOps s r Get;
 PutOp : s  -> (() -> r) -> StateOps s r Put

foo : Int <Eff State (StateOps Int) {Get, Put}>
foo = let
  y   <- call GetOp ();
  [z] <- pure (moveInt y);
  ()  <- call PutOp (z + 1) in
  pure z

-- handle : (sig s r e -> m b) -> (a <Code sig efs>) -> m a

data Incr t where
   Incr : Int → t → Incr t

data Recall t where
   Recall : (Int → t) → Recall t

data Sum (s : Type → Type) (t : Type → Type) a where
   Left : s a → Sum s t a;
   Right : t a → Sum s t a

data Mem where Mem : Int → Mem

unMem : Mem → Int
unMem x =
   case x of
     (Mem i) → i

algIncr : ∀ {a : Type} . Incr (Mem → (a , Mem)) → (Mem → (a , Mem))
algIncr x =
  case x of
    (Incr n t) → λx → t (Mem (unMem x + n))

algRecall : ∀ {a : Type} . Recall (Mem [∞] → (a, Mem)) → (Mem [∞] → (a , Mem))
algRecall x =
   case x of
    (Recall f) → λ[x] → f (unMem x) [Mem (unMem x)]

algSum : ∀ {a : Type, b : Type, f : Type → Type, g : Type → Type}
       .  (f a → a) [0..1]
       → (g a → a) [0..1]
       → Sum f g a → a
algSum [j] [k] x =
  case x of
    (Left y)  → j y;
    (Right z) → k z

-- Expressions
--data Expr a where
--  Recall : N
