data Vec (n : Nat) t where
  Nil  : Vec 0 t;
  Cons : t -> Vec n t -> Vec (n+1) t

--data Vec : Nat -> Type -> Type where
--  Nil : forall (a : Type) . Vec 0 a;
--  Cons : forall (a : Type, n : Nat) . a -> Vec n a -> Vec (n+1) a


everyOther : forall a : Type, b : Type, n : Nat
          . (a -> b) [n] -> Vec (n) (a [0..1]) -> Vec n b
everyOther [f] Nil = Nil;
everyOther [f] (Cons [x] (Cons [_] xs)) = Cons (f x) (everyOther [f] xs)
