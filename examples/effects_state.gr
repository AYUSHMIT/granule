import State

data Labels = Get | Put

data StateOps (s : Type) (r : Type) : Labels -> Type where
 GetOp : () -> (s -> r) [1 : Ext Nat] -> StateOps s r Get;
 PutOp : s [0..Inf] -> (() -> r) [1 : Ext Nat] -> StateOps s r Put

fmap_stateops : forall {s a b : Type, l : Labels}
              . (a -> b) [0..Inf] -> StateOps s a l -> StateOps s b l
fmap_stateops [f] (GetOp () [k]) = GetOp () [f . k];
fmap_stateops [f] (PutOp [s] [k]) = PutOp [s] [f . k]

foo : Int <Eff Labels (StateOps Int) {Get, Put}>
foo = let
  y   <- call GetOp ();
  [z] <- pure (moveInt y);
  ()  <- call PutOp [z + 1] in
  pure z

-- Handler
stateHandler : forall {s r : Type, l : Labels}
             . StateOps s (State s r) l -> State s r
stateHandler (GetOp () [k]) = join_state (State (\([s] : s [0..Inf]) -> (k s, [s])));
stateHandler (PutOp s [k])  = join_state (State (\([_] : s [0..Inf]) -> (k (), s)))

-- Handle state wrapped
handleState : forall {a b : Type, e : Set Labels, s : Type}
            . (forall {l : Labels} . StateOps s b l -> b) [0..Inf]
           -> (a -> b)
           -> a <Eff Labels (StateOps s) e>
           -> b
handleState = handle (/\{a,b,l}.fmap_stateops)

go : State Int Int
go = handleState [/\{l}.stateHandler] (return_state) foo

main : (Int, Int [])
main = runState go [42]