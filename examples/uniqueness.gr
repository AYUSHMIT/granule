
redeem : forall {p, q : Type} . (p [] -> q [Unique]) -> p [Unique] -> q [Unique]
redeem f x = f (uniqueReturn x)

-- Can't implement this as we can't go from p (linear) to p []
redeem' : forall {p, q : Type} . (p [] -> q) -> p -> q
redeem' = ?

weaken : forall {p, q, r : Type} . (q [Unique] -> r [Unique]) -> p [] -> q [Unique] -> r [Unique]
weaken f [a] b = f b

weaken' : forall {p, q, r : Type} . (q -> r) -> p [] -> q -> r
weaken' f [a] b = f b

contract : forall {p, q : Type} . (p [] -> p [] -> q [Unique]) -> p [] -> q [Unique]
contract f [a] = f [a] [a]

contract' : forall {p, q : Type} . (p [] -> p [] -> q) -> p [] -> q
contract' f [a] = f [a] [a]

-- Can't implement this as we can't go from p [] to p [Unique]
derelict : forall {p, q, r : Type} . (p [Unique] -> q [Unique]) -> p [] -> q [Unique]
-- derelict f [a] = f a
derelict = ?

derelict' : forall {p, q, r : Type} . (p -> q) -> p [] -> q
derelict' f [a] = f a