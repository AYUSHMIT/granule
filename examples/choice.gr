-- Example of how type polymorphism nicely takes care of mixing different levels
-- of nonlinearity.

import Choice
import Prelude

-- The `Choice` api for reference:
-- choice : a [0..1] -> b [0..1] -> Choice a b
-- choose1 : Choice a b -> a
-- choose2 : Choice a b -> b

--- Square a number, but only if the guard is true
squareOrIdentity : Bool -> Int [1..2] -> Int
squareOrIdentity g [n] = if g then n * n else n

example : Int
example =
  let [myChoice] : (Choice (Int [1..2]) Bool) [2]
    = [choice [[2]] [True]] in
  let b = choose2 myChoice in
  let i = choose1 myChoice in
  squareOrIdentity b i

-- The type annotation in the `let` isn't even needed:
main : Int
main =
  let [myChoice] = [choice [[2]] [True]] in -- the grade `[2]` gets inferred
  let b = choose2 myChoice in
  let i = choose1 myChoice in
  squareOrIdentity b i
